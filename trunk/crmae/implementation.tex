

% implementation ---architecture -- adwait

\begin{figure*} [t]
%\begin{figure*} [t]
\centering
 \psfig{figure=figures/arch.eps, width=4.5in, height=3.5in}
 \hrule
 \caption{\label{fig:cdf} \scriptsize \bf Architecture}
%\end{figure*}
\end{figure*}


We observe from the figure~\ref{fig:distribution} that approximately 50\% of L2 cache blocks are refreshed within 10ms interval. The substantial number of blocks after this interval underscores the need of strong architecture support. In this section we will first describe our counter design for keeping track of retention time of blocks. After that we will propose our micro-architecture solution to handle blocks which stay unrefreshed for longer time compared to retention time. 

\noindent\textbf{Counter Design:}
We maintain a 2 bit counter per physical block similar to the one used in \cite{marget}. Figure~\ref{fig:arch} (b) shows the transition diagram for the counter. Each cache block can be in one of the four states. We divide the retention time of the STT-RAM cell into four equal parts and define each part as {\it transition time}. After every {\it transition time}, block goes from one state to another according to the transition diagram. The block goes back to {\it S0} state if the data is refreshed. The block in {\it S3} state indicates that it has attained its retention time. We calculate the overhead of 2 bit counters to be 1.6\% over L2 cache size.

\subsection{{Volatile STT-RAM Scheme}}
In this naive design, if a particular block is dirty and is in S3 state, then it is written back to the main memory. This design has no microarchitecture overhead but has negative impact on the performance for two reasons: 1) There will be large number of write backs to the main memory after every interval. 2) The S3 state block could have been in MRU position because of frequent reads and losing it will incur additional read misses. We evaluate the results of using this scheme in Section 7.

Figure~\ref{fig:architecture} shows the schematic of overall architecture design. 
\noindent\textbf{Buffer Overflow detector:}
We keep a per bank small buffer with fixed number of entries made up of low-retention time STT-RAM cells, to temporarily store dead blocks. The optimal size of this buffer is calculated later in the section.

\noindent\textbf{Buffer Controller}
We maintain a 12 bit overflow detector per buffer and 12 bit block identifier associated with every buffer entry in the buffer controller. If a S3 state block is directed to the buffer, overflow detector is checked to see the occupancy of the buffer. If the buffer can hold blocks, a block id  is generated by concatenating its set and way id and stored along with actual block in one of the empty buffer slots. If the buffer is fully occupied, then block needs to be written back if it is dirty, otherwise it is invalidated.

\subsection{\sloppy{Schemes}}

\noindent{\sloppy{Revived STT-RAM Scheme}}
We propose our scheme 

\begin{figure*} [t]
%\begin{figure*} [t]
\centering
 \psfig{figure=figures/cdf.eps, width=6.9in, height=2.5in}
 \hrule
 \caption{\label{fig:cdf} \scriptsize \bf CDF}
%\end{figure*}
\end{figure*}

Revived STT-RAM Scheme is hereby proposed. We try to find the position of the block from MRU. If the block
is in certain slots from the MRU, we will use a small buffer bank to copy the dying block in the buffer and again
copy back to the same slot. If the block is not in chosen MRU slots we 
This method has multiple advantages: 1) It helps in preserving the frequently 
used block, which is most likely is frequently read. 2) It prevents unnecessary write backs from L2 cache to 
main memory. 

Our scheme consists of following parameters to be tuned. 1) Number of MRU Slots 2) Number of Buffer Slots
3) Possible retention times. ~\ref{fig:cdf} suggests that if we consider first eight MRU slots for buffering, we cover
x percentage of blocks. 


%1. We used a 2 bit counter per block to detect the block whether it has attained its retention time or not
%2. 16ways -- 4MB l2 stt-ram cache
%3. buffer of 1800 blocks is used (mean)..sensitivty --use 2100 blocks for confidence intervals
%4. how 8 slots?
%5. buffering which blocks
%6. how to buffer
%7. correctness issues -- copy dirty blocks
%8. buffer overflow checking
%9. if slots > 8, then check if RT is attained 
%10. RT - attained -- if dirty (Write back, otherwise invalidate)
%11.
